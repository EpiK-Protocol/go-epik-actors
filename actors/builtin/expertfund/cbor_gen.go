// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package expertfund

import (
	"fmt"
	"io"

	abi "github.com/filecoin-project/go-state-types/abi"
	expert "github.com/filecoin-project/specs-actors/v2/actors/builtin/expert"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf

var lengthBufState = []byte{137}

func (t *State) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufState); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Experts (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.Experts); err != nil {
		return xerrors.Errorf("failed to write cid field t.Experts: %w", err)
	}

	// t.ExpertsCount (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.ExpertsCount)); err != nil {
		return err
	}

	// t.TrackedExperts (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.TrackedExperts); err != nil {
		return xerrors.Errorf("failed to write cid field t.TrackedExperts: %w", err)
	}

	// t.PoolInfo (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.PoolInfo); err != nil {
		return xerrors.Errorf("failed to write cid field t.PoolInfo: %w", err)
	}

	// t.Datas (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.Datas); err != nil {
		return xerrors.Errorf("failed to write cid field t.Datas: %w", err)
	}

	// t.TotalExpertDataSize (abi.PaddedPieceSize) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.TotalExpertDataSize)); err != nil {
		return err
	}

	// t.TotalExpertReward (big.Int) (struct)
	if err := t.TotalExpertReward.MarshalCBOR(w); err != nil {
		return err
	}

	// t.LastFundBalance (big.Int) (struct)
	if err := t.LastFundBalance.MarshalCBOR(w); err != nil {
		return err
	}

	// t.DataStoreThreshold (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DataStoreThreshold)); err != nil {
		return err
	}

	return nil
}

func (t *State) UnmarshalCBOR(r io.Reader) error {
	*t = State{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 9 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Experts (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Experts: %w", err)
		}

		t.Experts = c

	}
	// t.ExpertsCount (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.ExpertsCount = uint64(extra)

	}
	// t.TrackedExperts (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.TrackedExperts: %w", err)
		}

		t.TrackedExperts = c

	}
	// t.PoolInfo (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PoolInfo: %w", err)
		}

		t.PoolInfo = c

	}
	// t.Datas (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Datas: %w", err)
		}

		t.Datas = c

	}
	// t.TotalExpertDataSize (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.TotalExpertDataSize = abi.PaddedPieceSize(extra)

	}
	// t.TotalExpertReward (big.Int) (struct)

	{

		if err := t.TotalExpertReward.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.TotalExpertReward: %w", err)
		}

	}
	// t.LastFundBalance (big.Int) (struct)

	{

		if err := t.LastFundBalance.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.LastFundBalance: %w", err)
		}

	}
	// t.DataStoreThreshold (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DataStoreThreshold = uint64(extra)

	}
	return nil
}

var lengthBufPoolInfo = []byte{130}

func (t *PoolInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufPoolInfo); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.LastRewardBlock (abi.ChainEpoch) (int64)
	if t.LastRewardBlock >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.LastRewardBlock)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.LastRewardBlock-1)); err != nil {
			return err
		}
	}

	// t.AccPerShare (big.Int) (struct)
	if err := t.AccPerShare.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *PoolInfo) UnmarshalCBOR(r io.Reader) error {
	*t = PoolInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.LastRewardBlock (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.LastRewardBlock = abi.ChainEpoch(extraI)
	}
	// t.AccPerShare (big.Int) (struct)

	{

		if err := t.AccPerShare.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.AccPerShare: %w", err)
		}

	}
	return nil
}

var lengthBufExpertInfo = []byte{133}

func (t *ExpertInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufExpertInfo); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.DataSize (abi.PaddedPieceSize) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DataSize)); err != nil {
		return err
	}

	// t.RewardDebt (big.Int) (struct)
	if err := t.RewardDebt.MarshalCBOR(w); err != nil {
		return err
	}

	// t.LockedFunds (big.Int) (struct)
	if err := t.LockedFunds.MarshalCBOR(w); err != nil {
		return err
	}

	// t.VestingFunds (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.VestingFunds); err != nil {
		return xerrors.Errorf("failed to write cid field t.VestingFunds: %w", err)
	}

	// t.UnlockedFunds (big.Int) (struct)
	if err := t.UnlockedFunds.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *ExpertInfo) UnmarshalCBOR(r io.Reader) error {
	*t = ExpertInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 5 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.DataSize (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DataSize = abi.PaddedPieceSize(extra)

	}
	// t.RewardDebt (big.Int) (struct)

	{

		if err := t.RewardDebt.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.RewardDebt: %w", err)
		}

	}
	// t.LockedFunds (big.Int) (struct)

	{

		if err := t.LockedFunds.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.LockedFunds: %w", err)
		}

	}
	// t.VestingFunds (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.VestingFunds: %w", err)
		}

		t.VestingFunds = c

	}
	// t.UnlockedFunds (big.Int) (struct)

	{

		if err := t.UnlockedFunds.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.UnlockedFunds: %w", err)
		}

	}
	return nil
}

var lengthBufClaimFundParams = []byte{130}

func (t *ClaimFundParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufClaimFundParams); err != nil {
		return err
	}

	// t.Expert (address.Address) (struct)
	if err := t.Expert.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *ClaimFundParams) UnmarshalCBOR(r io.Reader) error {
	*t = ClaimFundParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Expert (address.Address) (struct)

	{

		if err := t.Expert.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Expert: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufVestingFunds = []byte{129}

func (t *VestingFunds) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufVestingFunds); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Funds ([]expertfund.VestingFund) (slice)
	if len(t.Funds) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Funds was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajArray, uint64(len(t.Funds))); err != nil {
		return err
	}
	for _, v := range t.Funds {
		if err := v.MarshalCBOR(w); err != nil {
			return err
		}
	}
	return nil
}

func (t *VestingFunds) UnmarshalCBOR(r io.Reader) error {
	*t = VestingFunds{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Funds ([]expertfund.VestingFund) (slice)

	maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Funds: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Funds = make([]VestingFund, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v VestingFund
		if err := v.UnmarshalCBOR(br); err != nil {
			return err
		}

		t.Funds[i] = v
	}

	return nil
}

var lengthBufVestingFund = []byte{130}

func (t *VestingFund) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufVestingFund); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Epoch (abi.ChainEpoch) (int64)
	if t.Epoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.Epoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.Epoch-1)); err != nil {
			return err
		}
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *VestingFund) UnmarshalCBOR(r io.Reader) error {
	*t = VestingFund{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Epoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.Epoch = abi.ChainEpoch(extraI)
	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufGetDataParams = []byte{129}

func (t *GetDataParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufGetDataParams); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.PieceID (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.PieceID); err != nil {
		return xerrors.Errorf("failed to write cid field t.PieceID: %w", err)
	}

	return nil
}

func (t *GetDataParams) UnmarshalCBOR(r io.Reader) error {
	*t = GetDataParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.PieceID (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PieceID: %w", err)
		}

		t.PieceID = c

	}
	return nil
}

var lengthBufDataInfo = []byte{130}

func (t *DataInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufDataInfo); err != nil {
		return err
	}

	// t.Expert (address.Address) (struct)
	if err := t.Expert.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Data (expert.DataOnChainInfo) (struct)
	if err := t.Data.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *DataInfo) UnmarshalCBOR(r io.Reader) error {
	*t = DataInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Expert (address.Address) (struct)

	{

		if err := t.Expert.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Expert: %w", err)
		}

	}
	// t.Data (expert.DataOnChainInfo) (struct)

	{

		b, err := br.ReadByte()
		if err != nil {
			return err
		}
		if b != cbg.CborNull[0] {
			if err := br.UnreadByte(); err != nil {
				return err
			}
			t.Data = new(expert.DataOnChainInfo)
			if err := t.Data.UnmarshalCBOR(br); err != nil {
				return xerrors.Errorf("unmarshaling t.Data pointer: %w", err)
			}
		}

	}
	return nil
}

var lengthBufChangeThresholdParams = []byte{129}

func (t *ChangeThresholdParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufChangeThresholdParams); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.DataStoreThreshold (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DataStoreThreshold)); err != nil {
		return err
	}

	return nil
}

func (t *ChangeThresholdParams) UnmarshalCBOR(r io.Reader) error {
	*t = ChangeThresholdParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.DataStoreThreshold (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DataStoreThreshold = uint64(extra)

	}
	return nil
}

var lengthBufApplyForExpertParams = []byte{130}

func (t *ApplyForExpertParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufApplyForExpertParams); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(w); err != nil {
		return err
	}

	// t.ApplicationHash (string) (string)
	if len(t.ApplicationHash) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.ApplicationHash was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.ApplicationHash))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.ApplicationHash)); err != nil {
		return err
	}
	return nil
}

func (t *ApplyForExpertParams) UnmarshalCBOR(r io.Reader) error {
	*t = ApplyForExpertParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.ApplicationHash (string) (string)

	{
		sval, err := cbg.ReadStringBuf(br, scratch)
		if err != nil {
			return err
		}

		t.ApplicationHash = string(sval)
	}
	return nil
}

var lengthBufApplyForExpertReturn = []byte{130}

func (t *ApplyForExpertReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufApplyForExpertReturn); err != nil {
		return err
	}

	// t.IDAddress (address.Address) (struct)
	if err := t.IDAddress.MarshalCBOR(w); err != nil {
		return err
	}

	// t.RobustAddress (address.Address) (struct)
	if err := t.RobustAddress.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *ApplyForExpertReturn) UnmarshalCBOR(r io.Reader) error {
	*t = ApplyForExpertReturn{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.IDAddress (address.Address) (struct)

	{

		if err := t.IDAddress.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.IDAddress: %w", err)
		}

	}
	// t.RobustAddress (address.Address) (struct)

	{

		if err := t.RobustAddress.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.RobustAddress: %w", err)
		}

	}
	return nil
}
