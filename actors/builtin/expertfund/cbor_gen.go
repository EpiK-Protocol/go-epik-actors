// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package expertfund

import (
	"fmt"
	"io"

	abi "github.com/filecoin-project/go-state-types/abi"
	expert "github.com/filecoin-project/specs-actors/v2/actors/builtin/expert"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf

var lengthBufState = []byte{134}

func (t *State) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufState); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Experts (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.Experts); err != nil {
		return xerrors.Errorf("failed to write cid field t.Experts: %w", err)
	}

	// t.DisqualifiedExperts (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.DisqualifiedExperts); err != nil {
		return xerrors.Errorf("failed to write cid field t.DisqualifiedExperts: %w", err)
	}

	// t.PoolInfo (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.PoolInfo); err != nil {
		return xerrors.Errorf("failed to write cid field t.PoolInfo: %w", err)
	}

	// t.PieceInfos (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.PieceInfos); err != nil {
		return xerrors.Errorf("failed to write cid field t.PieceInfos: %w", err)
	}

	// t.DataStoreThreshold (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DataStoreThreshold)); err != nil {
		return err
	}

	// t.DailyImportSizeThreshold (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DailyImportSizeThreshold)); err != nil {
		return err
	}

	return nil
}

func (t *State) UnmarshalCBOR(r io.Reader) error {
	*t = State{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Experts (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Experts: %w", err)
		}

		t.Experts = c

	}
	// t.DisqualifiedExperts (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.DisqualifiedExperts: %w", err)
		}

		t.DisqualifiedExperts = c

	}
	// t.PoolInfo (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PoolInfo: %w", err)
		}

		t.PoolInfo = c

	}
	// t.PieceInfos (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PieceInfos: %w", err)
		}

		t.PieceInfos = c

	}
	// t.DataStoreThreshold (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DataStoreThreshold = uint64(extra)

	}
	// t.DailyImportSizeThreshold (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DailyImportSizeThreshold = uint64(extra)

	}
	return nil
}

var lengthBufPoolInfo = []byte{134}

func (t *PoolInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufPoolInfo); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.AccPerShare (big.Int) (struct)
	if err := t.AccPerShare.MarshalCBOR(w); err != nil {
		return err
	}

	// t.LastRewardBalance (big.Int) (struct)
	if err := t.LastRewardBalance.MarshalCBOR(w); err != nil {
		return err
	}

	// t.PrevEpoch (abi.ChainEpoch) (int64)
	if t.PrevEpoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.PrevEpoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.PrevEpoch-1)); err != nil {
			return err
		}
	}

	// t.PrevTotalDataSize (abi.PaddedPieceSize) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.PrevTotalDataSize)); err != nil {
		return err
	}

	// t.CurrentEpoch (abi.ChainEpoch) (int64)
	if t.CurrentEpoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.CurrentEpoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.CurrentEpoch-1)); err != nil {
			return err
		}
	}

	// t.CurrentTotalDataSize (abi.PaddedPieceSize) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.CurrentTotalDataSize)); err != nil {
		return err
	}

	return nil
}

func (t *PoolInfo) UnmarshalCBOR(r io.Reader) error {
	*t = PoolInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.AccPerShare (big.Int) (struct)

	{

		if err := t.AccPerShare.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.AccPerShare: %w", err)
		}

	}
	// t.LastRewardBalance (big.Int) (struct)

	{

		if err := t.LastRewardBalance.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.LastRewardBalance: %w", err)
		}

	}
	// t.PrevEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.PrevEpoch = abi.ChainEpoch(extraI)
	}
	// t.PrevTotalDataSize (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.PrevTotalDataSize = abi.PaddedPieceSize(extra)

	}
	// t.CurrentEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.CurrentEpoch = abi.ChainEpoch(extraI)
	}
	// t.CurrentTotalDataSize (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.CurrentTotalDataSize = abi.PaddedPieceSize(extra)

	}
	return nil
}

var lengthBufExpertInfo = []byte{134}

func (t *ExpertInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufExpertInfo); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.DataSize (abi.PaddedPieceSize) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DataSize)); err != nil {
		return err
	}

	// t.Active (bool) (bool)
	if err := cbg.WriteBool(w, t.Active); err != nil {
		return err
	}

	// t.RewardDebt (big.Int) (struct)
	if err := t.RewardDebt.MarshalCBOR(w); err != nil {
		return err
	}

	// t.LockedFunds (big.Int) (struct)
	if err := t.LockedFunds.MarshalCBOR(w); err != nil {
		return err
	}

	// t.VestingFunds (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.VestingFunds); err != nil {
		return xerrors.Errorf("failed to write cid field t.VestingFunds: %w", err)
	}

	// t.UnlockedFunds (big.Int) (struct)
	if err := t.UnlockedFunds.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *ExpertInfo) UnmarshalCBOR(r io.Reader) error {
	*t = ExpertInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 6 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.DataSize (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DataSize = abi.PaddedPieceSize(extra)

	}
	// t.Active (bool) (bool)

	maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajOther {
		return fmt.Errorf("booleans must be major type 7")
	}
	switch extra {
	case 20:
		t.Active = false
	case 21:
		t.Active = true
	default:
		return fmt.Errorf("booleans are either major type 7, value 20 or 21 (got %d)", extra)
	}
	// t.RewardDebt (big.Int) (struct)

	{

		if err := t.RewardDebt.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.RewardDebt: %w", err)
		}

	}
	// t.LockedFunds (big.Int) (struct)

	{

		if err := t.LockedFunds.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.LockedFunds: %w", err)
		}

	}
	// t.VestingFunds (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.VestingFunds: %w", err)
		}

		t.VestingFunds = c

	}
	// t.UnlockedFunds (big.Int) (struct)

	{

		if err := t.UnlockedFunds.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.UnlockedFunds: %w", err)
		}

	}
	return nil
}

var lengthBufPieceInfo = []byte{130}

func (t *PieceInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufPieceInfo); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Expert (address.Address) (struct)
	if err := t.Expert.MarshalCBOR(w); err != nil {
		return err
	}

	// t.DepositThreshold (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DepositThreshold)); err != nil {
		return err
	}

	return nil
}

func (t *PieceInfo) UnmarshalCBOR(r io.Reader) error {
	*t = PieceInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Expert (address.Address) (struct)

	{

		if err := t.Expert.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Expert: %w", err)
		}

	}
	// t.DepositThreshold (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DepositThreshold = uint64(extra)

	}
	return nil
}

var lengthBufExpertReward = []byte{131}

func (t *ExpertReward) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufExpertReward); err != nil {
		return err
	}

	// t.ExpertInfo (expertfund.ExpertInfo) (struct)
	if err := t.ExpertInfo.MarshalCBOR(w); err != nil {
		return err
	}

	// t.PendingFunds (big.Int) (struct)
	if err := t.PendingFunds.MarshalCBOR(w); err != nil {
		return err
	}

	// t.TotalReward (big.Int) (struct)
	if err := t.TotalReward.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *ExpertReward) UnmarshalCBOR(r io.Reader) error {
	*t = ExpertReward{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.ExpertInfo (expertfund.ExpertInfo) (struct)

	{

		if err := t.ExpertInfo.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.ExpertInfo: %w", err)
		}

	}
	// t.PendingFunds (big.Int) (struct)

	{

		if err := t.PendingFunds.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.PendingFunds: %w", err)
		}

	}
	// t.TotalReward (big.Int) (struct)

	{

		if err := t.TotalReward.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.TotalReward: %w", err)
		}

	}
	return nil
}

var lengthBufClaimFundParams = []byte{130}

func (t *ClaimFundParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufClaimFundParams); err != nil {
		return err
	}

	// t.Expert (address.Address) (struct)
	if err := t.Expert.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Amount (big.Int) (struct)
	if err := t.Amount.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *ClaimFundParams) UnmarshalCBOR(r io.Reader) error {
	*t = ClaimFundParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Expert (address.Address) (struct)

	{

		if err := t.Expert.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Expert: %w", err)
		}

	}
	// t.Amount (big.Int) (struct)

	{

		if err := t.Amount.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Amount: %w", err)
		}

	}
	return nil
}

var lengthBufGetDataReturn = []byte{130}

func (t *GetDataReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufGetDataReturn); err != nil {
		return err
	}

	// t.Expert (address.Address) (struct)
	if err := t.Expert.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Data (expert.DataOnChainInfo) (struct)
	if err := t.Data.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *GetDataReturn) UnmarshalCBOR(r io.Reader) error {
	*t = GetDataReturn{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Expert (address.Address) (struct)

	{

		if err := t.Expert.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Expert: %w", err)
		}

	}
	// t.Data (expert.DataOnChainInfo) (struct)

	{

		b, err := br.ReadByte()
		if err != nil {
			return err
		}
		if b != cbg.CborNull[0] {
			if err := br.UnreadByte(); err != nil {
				return err
			}
			t.Data = new(expert.DataOnChainInfo)
			if err := t.Data.UnmarshalCBOR(br); err != nil {
				return xerrors.Errorf("unmarshaling t.Data pointer: %w", err)
			}
		}

	}
	return nil
}

var lengthBufChangeThresholdParams = []byte{130}

func (t *ChangeThresholdParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufChangeThresholdParams); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.DataStoreThreshold (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DataStoreThreshold)); err != nil {
		return err
	}

	// t.DailyImportThreshold (uint64) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DailyImportThreshold)); err != nil {
		return err
	}

	return nil
}

func (t *ChangeThresholdParams) UnmarshalCBOR(r io.Reader) error {
	*t = ChangeThresholdParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.DataStoreThreshold (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DataStoreThreshold = uint64(extra)

	}
	// t.DailyImportThreshold (uint64) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.DailyImportThreshold = uint64(extra)

	}
	return nil
}

var lengthBufApplyForExpertParams = []byte{130}

func (t *ApplyForExpertParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufApplyForExpertParams); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Owner (address.Address) (struct)
	if err := t.Owner.MarshalCBOR(w); err != nil {
		return err
	}

	// t.ApplicationHash (string) (string)
	if len(t.ApplicationHash) > cbg.MaxLength {
		return xerrors.Errorf("Value in field t.ApplicationHash was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajTextString, uint64(len(t.ApplicationHash))); err != nil {
		return err
	}
	if _, err := io.WriteString(w, string(t.ApplicationHash)); err != nil {
		return err
	}
	return nil
}

func (t *ApplyForExpertParams) UnmarshalCBOR(r io.Reader) error {
	*t = ApplyForExpertParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Owner (address.Address) (struct)

	{

		if err := t.Owner.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Owner: %w", err)
		}

	}
	// t.ApplicationHash (string) (string)

	{
		sval, err := cbg.ReadStringBuf(br, scratch)
		if err != nil {
			return err
		}

		t.ApplicationHash = string(sval)
	}
	return nil
}

var lengthBufApplyForExpertReturn = []byte{130}

func (t *ApplyForExpertReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufApplyForExpertReturn); err != nil {
		return err
	}

	// t.IDAddress (address.Address) (struct)
	if err := t.IDAddress.MarshalCBOR(w); err != nil {
		return err
	}

	// t.RobustAddress (address.Address) (struct)
	if err := t.RobustAddress.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *ApplyForExpertReturn) UnmarshalCBOR(r io.Reader) error {
	*t = ApplyForExpertReturn{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.IDAddress (address.Address) (struct)

	{

		if err := t.IDAddress.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.IDAddress: %w", err)
		}

	}
	// t.RobustAddress (address.Address) (struct)

	{

		if err := t.RobustAddress.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.RobustAddress: %w", err)
		}

	}
	return nil
}

var lengthBufCheckedPiece = []byte{130}

func (t *CheckedPiece) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufCheckedPiece); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.PieceCID (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.PieceCID); err != nil {
		return xerrors.Errorf("failed to write cid field t.PieceCID: %w", err)
	}

	// t.PieceSize (abi.PaddedPieceSize) (uint64)

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.PieceSize)); err != nil {
		return err
	}

	return nil
}

func (t *CheckedPiece) UnmarshalCBOR(r io.Reader) error {
	*t = CheckedPiece{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.PieceCID (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PieceCID: %w", err)
		}

		t.PieceCID = c

	}
	// t.PieceSize (abi.PaddedPieceSize) (uint64)

	{

		maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
		if err != nil {
			return err
		}
		if maj != cbg.MajUnsignedInt {
			return fmt.Errorf("wrong type for uint64 field")
		}
		t.PieceSize = abi.PaddedPieceSize(extra)

	}
	return nil
}

var lengthBufBatchCheckDataParams = []byte{129}

func (t *BatchCheckDataParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufBatchCheckDataParams); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.CheckedPieces ([]expertfund.CheckedPiece) (slice)
	if len(t.CheckedPieces) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.CheckedPieces was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajArray, uint64(len(t.CheckedPieces))); err != nil {
		return err
	}
	for _, v := range t.CheckedPieces {
		if err := v.MarshalCBOR(w); err != nil {
			return err
		}
	}
	return nil
}

func (t *BatchCheckDataParams) UnmarshalCBOR(r io.Reader) error {
	*t = BatchCheckDataParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.CheckedPieces ([]expertfund.CheckedPiece) (slice)

	maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.CheckedPieces: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.CheckedPieces = make([]CheckedPiece, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v CheckedPiece
		if err := v.UnmarshalCBOR(br); err != nil {
			return err
		}

		t.CheckedPieces[i] = v
	}

	return nil
}

var lengthBufDisqualifiedExpertInfo = []byte{129}

func (t *DisqualifiedExpertInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufDisqualifiedExpertInfo); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.DisqualifiedAt (abi.ChainEpoch) (int64)
	if t.DisqualifiedAt >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.DisqualifiedAt)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.DisqualifiedAt-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *DisqualifiedExpertInfo) UnmarshalCBOR(r io.Reader) error {
	*t = DisqualifiedExpertInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.DisqualifiedAt (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.DisqualifiedAt = abi.ChainEpoch(extraI)
	}
	return nil
}
