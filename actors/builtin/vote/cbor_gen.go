// Code generated by github.com/whyrusleeping/cbor-gen. DO NOT EDIT.

package vote

import (
	"fmt"
	"io"

	address "github.com/filecoin-project/go-address"
	abi "github.com/filecoin-project/go-state-types/abi"
	big "github.com/filecoin-project/go-state-types/big"
	cbg "github.com/whyrusleeping/cbor-gen"
	xerrors "golang.org/x/xerrors"
)

var _ = xerrors.Errorf

var lengthBufState = []byte{139}

func (t *State) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufState); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Candidates (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.Candidates); err != nil {
		return xerrors.Errorf("failed to write cid field t.Candidates: %w", err)
	}

	// t.Voters (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.Voters); err != nil {
		return xerrors.Errorf("failed to write cid field t.Voters: %w", err)
	}

	// t.TotalVotes (big.Int) (struct)
	if err := t.TotalVotes.MarshalCBOR(w); err != nil {
		return err
	}

	// t.CurrEpoch (abi.ChainEpoch) (int64)
	if t.CurrEpoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.CurrEpoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.CurrEpoch-1)); err != nil {
			return err
		}
	}

	// t.CurrEpochEffectiveVotes (big.Int) (struct)
	if err := t.CurrEpochEffectiveVotes.MarshalCBOR(w); err != nil {
		return err
	}

	// t.CurrEpochRewards (big.Int) (struct)
	if err := t.CurrEpochRewards.MarshalCBOR(w); err != nil {
		return err
	}

	// t.PrevEpoch (abi.ChainEpoch) (int64)
	if t.PrevEpoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.PrevEpoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.PrevEpoch-1)); err != nil {
			return err
		}
	}

	// t.PrevEpochEarningsPerVote (big.Int) (struct)
	if err := t.PrevEpochEarningsPerVote.MarshalCBOR(w); err != nil {
		return err
	}

	// t.LastRewardBalance (big.Int) (struct)
	if err := t.LastRewardBalance.MarshalCBOR(w); err != nil {
		return err
	}

	// t.FallbackReceiver (address.Address) (struct)
	if err := t.FallbackReceiver.MarshalCBOR(w); err != nil {
		return err
	}

	// t.FallbackDebt (big.Int) (struct)
	if err := t.FallbackDebt.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *State) UnmarshalCBOR(r io.Reader) error {
	*t = State{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 11 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Candidates (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Candidates: %w", err)
		}

		t.Candidates = c

	}
	// t.Voters (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Voters: %w", err)
		}

		t.Voters = c

	}
	// t.TotalVotes (big.Int) (struct)

	{

		if err := t.TotalVotes.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.TotalVotes: %w", err)
		}

	}
	// t.CurrEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.CurrEpoch = abi.ChainEpoch(extraI)
	}
	// t.CurrEpochEffectiveVotes (big.Int) (struct)

	{

		if err := t.CurrEpochEffectiveVotes.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.CurrEpochEffectiveVotes: %w", err)
		}

	}
	// t.CurrEpochRewards (big.Int) (struct)

	{

		if err := t.CurrEpochRewards.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.CurrEpochRewards: %w", err)
		}

	}
	// t.PrevEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.PrevEpoch = abi.ChainEpoch(extraI)
	}
	// t.PrevEpochEarningsPerVote (big.Int) (struct)

	{

		if err := t.PrevEpochEarningsPerVote.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.PrevEpochEarningsPerVote: %w", err)
		}

	}
	// t.LastRewardBalance (big.Int) (struct)

	{

		if err := t.LastRewardBalance.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.LastRewardBalance: %w", err)
		}

	}
	// t.FallbackReceiver (address.Address) (struct)

	{

		if err := t.FallbackReceiver.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.FallbackReceiver: %w", err)
		}

	}
	// t.FallbackDebt (big.Int) (struct)

	{

		if err := t.FallbackDebt.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.FallbackDebt: %w", err)
		}

	}
	return nil
}

var lengthBufCandidate = []byte{131}

func (t *Candidate) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufCandidate); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.BlockEpoch (abi.ChainEpoch) (int64)
	if t.BlockEpoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.BlockEpoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.BlockEpoch-1)); err != nil {
			return err
		}
	}

	// t.BlockCumEarningsPerVote (big.Int) (struct)
	if err := t.BlockCumEarningsPerVote.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Votes (big.Int) (struct)
	if err := t.Votes.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *Candidate) UnmarshalCBOR(r io.Reader) error {
	*t = Candidate{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.BlockEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.BlockEpoch = abi.ChainEpoch(extraI)
	}
	// t.BlockCumEarningsPerVote (big.Int) (struct)

	{

		if err := t.BlockCumEarningsPerVote.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.BlockCumEarningsPerVote: %w", err)
		}

	}
	// t.Votes (big.Int) (struct)

	{

		if err := t.Votes.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Votes: %w", err)
		}

	}
	return nil
}

var lengthBufVoter = []byte{133}

func (t *Voter) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufVoter); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.SettleEpoch (abi.ChainEpoch) (int64)
	if t.SettleEpoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.SettleEpoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.SettleEpoch-1)); err != nil {
			return err
		}
	}

	// t.SettleCumEarningsPerVote (big.Int) (struct)
	if err := t.SettleCumEarningsPerVote.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Withdrawable (big.Int) (struct)
	if err := t.Withdrawable.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Tally (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.Tally); err != nil {
		return xerrors.Errorf("failed to write cid field t.Tally: %w", err)
	}

	// t.PrevTally (cid.Cid) (struct)

	if err := cbg.WriteCidBuf(scratch, w, t.PrevTally); err != nil {
		return xerrors.Errorf("failed to write cid field t.PrevTally: %w", err)
	}

	return nil
}

func (t *Voter) UnmarshalCBOR(r io.Reader) error {
	*t = Voter{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 5 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.SettleEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.SettleEpoch = abi.ChainEpoch(extraI)
	}
	// t.SettleCumEarningsPerVote (big.Int) (struct)

	{

		if err := t.SettleCumEarningsPerVote.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.SettleCumEarningsPerVote: %w", err)
		}

	}
	// t.Withdrawable (big.Int) (struct)

	{

		if err := t.Withdrawable.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Withdrawable: %w", err)
		}

	}
	// t.Tally (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.Tally: %w", err)
		}

		t.Tally = c

	}
	// t.PrevTally (cid.Cid) (struct)

	{

		c, err := cbg.ReadCid(br)
		if err != nil {
			return xerrors.Errorf("failed to read cid field t.PrevTally: %w", err)
		}

		t.PrevTally = c

	}
	return nil
}

var lengthBufVotesInfo = []byte{131}

func (t *VotesInfo) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufVotesInfo); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Votes (big.Int) (struct)
	if err := t.Votes.MarshalCBOR(w); err != nil {
		return err
	}

	// t.RescindingVotes (big.Int) (struct)
	if err := t.RescindingVotes.MarshalCBOR(w); err != nil {
		return err
	}

	// t.LastRescindEpoch (abi.ChainEpoch) (int64)
	if t.LastRescindEpoch >= 0 {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajUnsignedInt, uint64(t.LastRescindEpoch)); err != nil {
			return err
		}
	} else {
		if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajNegativeInt, uint64(-t.LastRescindEpoch-1)); err != nil {
			return err
		}
	}
	return nil
}

func (t *VotesInfo) UnmarshalCBOR(r io.Reader) error {
	*t = VotesInfo{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 3 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Votes (big.Int) (struct)

	{

		if err := t.Votes.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Votes: %w", err)
		}

	}
	// t.RescindingVotes (big.Int) (struct)

	{

		if err := t.RescindingVotes.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.RescindingVotes: %w", err)
		}

	}
	// t.LastRescindEpoch (abi.ChainEpoch) (int64)
	{
		maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
		var extraI int64
		if err != nil {
			return err
		}
		switch maj {
		case cbg.MajUnsignedInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 positive overflow")
			}
		case cbg.MajNegativeInt:
			extraI = int64(extra)
			if extraI < 0 {
				return fmt.Errorf("int64 negative oveflow")
			}
			extraI = -1 - extraI
		default:
			return fmt.Errorf("wrong type for int64 field: %d", maj)
		}

		t.LastRescindEpoch = abi.ChainEpoch(extraI)
	}
	return nil
}

var lengthBufRescindParams = []byte{130}

func (t *RescindParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufRescindParams); err != nil {
		return err
	}

	// t.Candidate (address.Address) (struct)
	if err := t.Candidate.MarshalCBOR(w); err != nil {
		return err
	}

	// t.Votes (big.Int) (struct)
	if err := t.Votes.MarshalCBOR(w); err != nil {
		return err
	}
	return nil
}

func (t *RescindParams) UnmarshalCBOR(r io.Reader) error {
	*t = RescindParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 2 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Candidate (address.Address) (struct)

	{

		if err := t.Candidate.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Candidate: %w", err)
		}

	}
	// t.Votes (big.Int) (struct)

	{

		if err := t.Votes.UnmarshalCBOR(br); err != nil {
			return xerrors.Errorf("unmarshaling t.Votes: %w", err)
		}

	}
	return nil
}

var lengthBufGetCandidatesParams = []byte{129}

func (t *GetCandidatesParams) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufGetCandidatesParams); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Addresses ([]address.Address) (slice)
	if len(t.Addresses) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Addresses was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajArray, uint64(len(t.Addresses))); err != nil {
		return err
	}
	for _, v := range t.Addresses {
		if err := v.MarshalCBOR(w); err != nil {
			return err
		}
	}
	return nil
}

func (t *GetCandidatesParams) UnmarshalCBOR(r io.Reader) error {
	*t = GetCandidatesParams{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Addresses ([]address.Address) (slice)

	maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Addresses: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Addresses = make([]address.Address, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v address.Address
		if err := v.UnmarshalCBOR(br); err != nil {
			return err
		}

		t.Addresses[i] = v
	}

	return nil
}

var lengthBufGetCandidatesReturn = []byte{129}

func (t *GetCandidatesReturn) MarshalCBOR(w io.Writer) error {
	if t == nil {
		_, err := w.Write(cbg.CborNull)
		return err
	}
	if _, err := w.Write(lengthBufGetCandidatesReturn); err != nil {
		return err
	}

	scratch := make([]byte, 9)

	// t.Votes ([]big.Int) (slice)
	if len(t.Votes) > cbg.MaxLength {
		return xerrors.Errorf("Slice value in field t.Votes was too long")
	}

	if err := cbg.WriteMajorTypeHeaderBuf(scratch, w, cbg.MajArray, uint64(len(t.Votes))); err != nil {
		return err
	}
	for _, v := range t.Votes {
		if err := v.MarshalCBOR(w); err != nil {
			return err
		}
	}
	return nil
}

func (t *GetCandidatesReturn) UnmarshalCBOR(r io.Reader) error {
	*t = GetCandidatesReturn{}

	br := cbg.GetPeeker(r)
	scratch := make([]byte, 8)

	maj, extra, err := cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}
	if maj != cbg.MajArray {
		return fmt.Errorf("cbor input should be of type array")
	}

	if extra != 1 {
		return fmt.Errorf("cbor input had wrong number of fields")
	}

	// t.Votes ([]big.Int) (slice)

	maj, extra, err = cbg.CborReadHeaderBuf(br, scratch)
	if err != nil {
		return err
	}

	if extra > cbg.MaxLength {
		return fmt.Errorf("t.Votes: array too large (%d)", extra)
	}

	if maj != cbg.MajArray {
		return fmt.Errorf("expected cbor array")
	}

	if extra > 0 {
		t.Votes = make([]big.Int, extra)
	}

	for i := 0; i < int(extra); i++ {

		var v big.Int
		if err := v.UnmarshalCBOR(br); err != nil {
			return err
		}

		t.Votes[i] = v
	}

	return nil
}
